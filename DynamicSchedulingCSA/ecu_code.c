/**********************************************************************************************************************
 * \file GTM_TOM_Interrupt.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxPort.h"
#include "IfxGtm_Tom_Timer.h"
#include <stdio.h>
#include <stdlib.h>
#include "CanBasicDemo-v1.h"
#include <Cpu/Irq/IfxCpu_Irq.h>
#include "IfxCpu.h"
#include <Math.h>
#include "time.h"
#include "Bsp.h"
#include "Ifx_types.h"
//#include "UART_VCOM.c"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_TOM      3                       /* Interrupt priority number                                    */
#define ISR_PRIORITY_TOM1     2                       /* Interrupt1 priority number                                   */
#define ISR_PRIORITY_TOM2     1                       /* Interrupt2 priority number                                   */
#define TOM_FREQ              100.0f                  /* TOM frequency                                                */
#define TOM_FREQ_1            120.0f                  /* TOM frequency                                                */
#define LED1                  &MODULE_P20, 12         /* LED which will be toggled in Interrupt Service Routine (ISR) */
#define LED2                  &MODULE_P20, 13
#define IFX_INTTOS_CAN_TXRX   0
#define MAX_TICKS             20
#define WAIT_TIME             3
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Tom_Timer g_timerDriver;                      /* TOM driver                                                   */
IfxGtm_Tom_Timer g_timerDriver1;                     /* TOM driver 1                                                 */
IfxGtm_Tom_Timer g_timerDriver2;                     /* TOM driver 2                                                 */
App_CanBasic g_CanBasic;
Ifx_TickTime g_tickFor3ms;
typedef struct {
    float util;
    int len;
    int h;
    int acess[];
} acess;

/*-------------------------------------------control/detection task-related variables--------------------------------------------------*/

/*qc Tx*/
const uint32 qc_tx_id[6] = {0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1};
const uint8 qc_tx_buf[6] = {1, 2, 3, 4, 5, 6};
IfxCan_Message txQc1;
IfxCan_Message txQc2;
IfxCan_Message txQc3;
IfxCan_Message txQc4;
uint32 txDataQC_alt[2];
uint32 txDataQC1[2];
uint32 txDataQC2[2];
const unsigned int QC_U_OFFSET[] = {200, 200, 200, 200};
const unsigned int QC_U_FACTOR[] = {1000, 1000, 1000, 1000};
const int qc_h_ct = 3;
const int qc_h_set[3] = {10, 20, 30};
//const int qc_subsys[3][2] = {{1, 10, 100},{1, 10},{1, 10}};
const float qc_dev_thres = 0.1;


/*qc Rx*/
const uint32 qc_rx_id[6] = {0x11, 0x21, 0x31, 0x41, 0x51, 0x61};//17;
const unsigned int QC_X_OFFSET[12] = {200, 200, 20, 20, 200, 200, 20, 20, 200, 200, 20, 20};
const unsigned int QC_X_FACTOR[12] = {1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000};
uint8 sensed_qc[2] = {0,0};
extern volatile __far int curIdx_qc_alt = 0;
extern volatile __far int curIdx_qc = 0;

extern volatile __far float xhat_QC_alt[4] = {0, 0, 0, 0};
extern volatile __far float xhat_QC[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
extern volatile __far uint32 y_QC[12] = {200000, 200000, 20000, 20000, 200000, 200000, 20000, 20000, 200000, 200000, 20000, 20000};//{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
extern volatile __far float u_QC_alt[2] = {0, 0};
extern volatile __far float u_QC[4] = {0, 0, 0, 0};

float QC_REF_alt[] = {10, 0, 0, 0};
float QC_REF[] = {10, 0, 0, 0, 10, 0, 0, 0, 10, 0, 0, 0};


/////*ttc Tx*/
////uint32 ttc_tx_id = 0xc4;
////uint8 ttc_tx_buf = 10;
////const unsigned int TTC_U1_offset = 200;
////const unsigned int TTC_U1_factor = 100;//10;
////const int ct_qc = 4;                         // no. of instances in hyperperiod
////const int css_qc[4] = {1,1,1,1};//{0,0,0,0};
//////const int ct_qc = 22;                         // no. of instances in hyperperiod
//////const int css_qc[22] = {1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1};//{0,0,0,0};
//////const int css_qc[22] = {1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0};//{0,0,0,0};
/////*ttc Rx*/
////uint32 ttc_rx_id = 0x121;
////const unsigned int TTC_XA_offset = 200;//20;
////const unsigned int TTC_XA_factor = 100;
////const unsigned int TTC_XB_offset = 200;//20;
////const unsigned int TTC_XB_factor = 100;
////uint8 sensed_qc = 0;
////extern volatile __far int curIdx_qc = 0;
///*ttc Tx*/
//const uint32 ttc_tx_id = 0xc4;
//const uint8 ttc_tx_buf = 2;
//IfxCan_Message txTtc;
//uint32 txDataTtc[2];
//const unsigned int TTC_U1_offset = 200;
//const unsigned int TTC_U1_factor = 100;//10;
//const int ttc_h_ct = 3;
//const int ttc_h_set[3] = {20, 25, 50};
//const int ttc_subsys[2][4] = {{1,10,100,1000},{1,10,-1,-1}};
//const float ttc_dev_thres = 85;
//
///*qc Rx*/
//const uint32 ttc_rx_id = 33;//0x21;
//const unsigned int TTC_XA_offset = 200;//20;
//const unsigned int TTC_XA_factor = 100;
//const unsigned int TTC_XB_offset = 200;//20;
//const unsigned int TTC_XB_factor = 100;
//uint8 sensed_qc = 0;
//extern volatile __far int curIdx_qc = 0;
///* ttc states */
//extern volatile __far float xhat_TTC[2] = {10,0};
//extern volatile __far uint32 y1_TTC = 0;
//extern volatile __far float u1_TTC = 0;
//extern volatile __far float xhatA_P5 = 10;
//extern volatile __far float xhatB_P5 = 0;
//extern volatile __far uint32 xA_P5 = 0;
//extern volatile __far uint32 xB_P5 = 0;
//extern volatile __far float u1_P5 = 0;// added 1
//
///*CC Tx*/
//const uint32 cc_tx_id = 0xd1;//0x1a1;
//const uint8 cc_tx_buf = 3;
//IfxCan_Message txCc;
//uint32 txDataCc[2];
//const unsigned int CC_U1_offset = 200;
//const unsigned int CC_U1_factor = 100;//10;
//const int cc_h_ct = 2;
//const int cc_h_set[2] = {10, 20};
//const int cc_subsys[2][2] = {{1,10},{1,10}};
//const float cc_dev_thres = 300;
//
///*CC Rx*/
//const uint32 cc_rx_id = 49;//0x31
//const unsigned int CC_XA_offset = 200;
//const unsigned int CC_XA_factor = 100;//100;
//uint8 sensed_cc = 0;
//extern volatile __far int curIdx_cc = 0;
///* cc states */
//extern volatile __far double xhat_CC[3] = {0,10,10};
//extern volatile __far uint32 y1_CC = 0;
//extern volatile __far double u1_CC = 0;
//
///*SC Tx*/
//const uint32 sc_tx_id = 0xf4;//0x1b1;
//const uint8 sc_tx_buf = 4;
//IfxCan_Message txSc;
//uint32 txDataSc[2];
//const unsigned int SC_U1_offset = 200;
//const unsigned int SC_U1_factor = 100;//10;
//const int sc_h_ct = 3;
//const int sc_h_set[3] = {40, 80, 120};
//const int sc_subsys[3][4] = {{11, 10, 100, 1000},{11, 10, 100, -1},{11, 10, -1, -1}};
//const float sc_dev_thres = 0.1;
//
///*SC Rx*/
//const uint32 sc_rx_id = 65;//0x41
//const unsigned int SC_XA_offset = 200;
//const unsigned int SC_XA_factor = 100;//100;
//uint8 sensed_sc = 0;
//extern volatile __far int curIdx_sc = 0;
///* sc states */
//extern volatile __far float xhat_SC[4] = {1,0.1,1,0.02};
//extern volatile __far uint32 y1_SC  = 0;
//extern volatile __far float u1_SC  = 0;
//
//
///*ABS Tx*/
//const uint32 abs_tx_id = 0xb2;
//const uint8 abs_tx_buf = 5;
//IfxCan_Message txAbs;
//uint32 txDataAbs[2];
//const unsigned int ABS_U1_offset = 100;
//const unsigned int ABS_U1_factor = 100;
//const int abs_h_ct = 2;
//const int abs_h_set[2] = {10,20};
//const int abs_subsys[2][2] = {{1,10},{1,-2}};
//const float abs_dev_thres = 0.2;
//
///*ABS Rx*/
//const uint32 abs_rx_id = 0x15;
//const unsigned int ABS_XA_offset = 100;
//const unsigned int ABS_XA_factor = 100;
//uint8 sensed_abs = 0;
//extern volatile __far int curIdx_abs = 0;
///* abs states */
//extern volatile __far float xhat_ABS[1] = {0};
//extern volatile __far uint32 y1_ABS = 0;
//extern volatile __far float u1_ABS = 0;


///* sba detector*/
//uint32 sba_dtc_tx_id = 0x11;
//const unsigned int Th_ct = 1;                  // threshold on sba attempt count
//uint8 sba_dtc_tx_buf = 3;
//volatile __far int sba_ct = 0;

extern volatile float done = 0;

volatile __far unsigned int __align32 core_0_online=0;
volatile __far unsigned int __align32 core_1_online=0;


clock_t last;

uint32 g_tick = 0;   //Resolution is 0.1ms
uint32 g_tick_ms = 0;
uint32 g_clock = 0;

/*---------------------------------------------- taskset details:{qc, qc_alt}----------------------------------------------------------*/
int ct_qc_alt = 20;
int ct_qc = 10;
int css_qc_alt[20] = {1,1,0,0,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,1};//{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};//
int css_qc[20] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};//{0,0,0,0,0,0,0,0,0,0};//
uint8 task_ct = 2;
//uint8 task_per[]= {2,2};    // current periodicity as index from tasks' h_sets (20,25,20,40)
uint8 task_wcet[] = {1, 2};
uint8 task_etct[] = {0, 0};
uint8 task_jobct[] = {20, 10};
int i=0, j=0, k=0, l=0, m=0;
uint8 sense[] = {0, 0};
uint32 wcet;
uint32 HP = 200;
float J[] ={0, 0};
float J_ub[] ={1000, 1000};
float J_lb[] ={5, 5};


int altlist[7][20] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0}, {1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,1,1,0}, {1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1},
                        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0}, {1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0}};//, {1,1,0,0,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,1}}; //{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
//int altlist[7][20] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
//                      {1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0}, {1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0}, {1,1,0,0,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,1}}; //{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
int lens_alt_list[] = {20, 20, 20, 20, 20, 20, 20};
int h_list[2][7] = {{10, 10, 10, 10, 20, 30, 30},{10, 10, 10, 10, 20, 20, 30}};//{{20, 20, 20, 20, 20, 30, 30},{10, 10, 10, 10, 20, 20, 30}}; //
int trajlist[7][20] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0}, {1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0}, {1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1},
                      {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
int lens_traj_list[] = {20, 20, 20, 20, 20, 20, 10, 10};
//uint8 h_traj_list[] = {10, 10, 10, 10, 20, 20, 30, 30};
uint8 task_acess[]= {5, 0};
uint8 task_access_ct[] = {7, 7};
//uint8 h_list[] = {h_alt_list, h_traj_list};
//uint8 h_list[1] = h_traj_list;
//uint8 ct_list[] = {ct_qc_alt, ct_qc};
uint8 task_per[]= {2, 2};    // current periodicity as index from tasks' h_sets (20,25,20,40)
/*------ test -------*/
extern volatile int allinst = 0;
/*********************/

/* ---------------------------- */
void t120_tx();
void t100_tx();
void t50_tx();
void t40_tx();
void t80_tx();
void t20_tx();
void t10_tx();
void t8_tx();
void dummy_comp1(void);
void sba_dtc(int);
int gcd(int, int);
int lcm(int, int);
int hp();
float calcUtil(int h, int acess, int HP, float wcet);
void updateutil(void);

static volatile uint32 numTxmsgs[IFXCAN_NUM_MODULES];
static volatile uint32 numRxmsgs[IFXCAN_NUM_MODULES];
uint8 rxmsg_atkwinlen = 0;
uint32 *rxmsg_atkwin[] = {0};//(uint32 *)calloc(10,sizeof(uint32));
//rxmsg_atkwin = (uint32 *)calloc(1,sizeof(uint32));//&rxmsg_atkwin;

typedef enum
{
    IfxCan_dedicatedBuffers,
    IfxCan_fifo0,
    IfxCan_fifo1,
}IfxCan_MsgMode;

static void ProcessFifo0Interrupt(uint32 , IfxCan_MsgMode);

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

IFX_INTERRUPT(Tx_Interrput1_ISR, IFX_INTTOS_CAN_TXRX, ISR_PRIORITY_CAN1_TX)
{
    Ifx_CAN   *canSfr = &MODULE_CAN1;
    if(CAN1_IR0.B.TC == 1)
    {
//        printf("transmitted\n");
        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
        IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_transmissionCompleted);
        numTxmsgs[1]++;
//        printf("Tx \n");
    }
}

IFX_INTERRUPT(Rx_Interrput0_ISR, IFX_INTTOS_CAN_TXRX, ISR_PRIORITY_CAN0_RX)// vectabnum=IFX_INTTOS_CAN_TXRX
{
    Ifx_CAN   *canSfr =  &MODULE_CAN0;
    if(CAN0_IR0.B.RF0N == 1)
    {
        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
        IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_rxFifo0NewMessage);
//        printf("int rx at %d\n",i);
        ProcessFifo0Interrupt (0 , IfxCan_fifo0);
        numRxmsgs[1]++;
    }
}

static void ProcessFifo0Interrupt (uint32 canNode , IfxCan_MsgMode rxMsgType)
{
    IfxCan_Message rxMsg;
    uint32 rxData[2];
    IfxCan_Can_initMessage(&rxMsg);

    rxData[0] = 0x00000000;
    rxData[1] = 0x00000000;

    rxMsg.readFromRxFifo1 = FALSE;
    rxMsg.readFromRxFifo0 = TRUE;
    IfxCan_Can_readMessage(&g_CanBasic.drivers.canNode[canNode], &rxMsg, rxData);
//    printf("rx %x at %d\n",rxMsg.messageId,i);
    /* test wcet hns */
    allinst++;
/*
//    vm msg;
//    traffic[allinst] = rxMsg.messageId;
//    allinst++;
//    if( traffic[allinst] == 0xA1 || traffic[allinst] == 0xB1 || traffic[allinst] == 0xC4){
//        msg.id = rxMsg.messageId;
//        msgs[inst] = msg;
//        inst ++ ;
//    }
*/
    /* for ttc */
    /*
    if (rxMsg.messageId < ttc_rx_id){
        rxmsg_atkwin[rxmsg_atkwinlen++] = rxMsg.messageId;
        *rxmsg_atkwin = (uint32*)realloc(rxmsg_atkwin,2*sizeof(uint32));
        for(int i = 0; i<=rxmsg_atkwinlen; i++)
            printf("ids in window of \n");
            //            printf("ids in window of %u:\t %u\n", ttc_rx_id, rxmsg_atkwin[i]);
    }else{
        rxmsg_atkwinlen = 0;
        free(rxmsg_atkwin);
        *rxmsg_atkwin = (uint32*)calloc(1,sizeof(uint32));
    }
    */
    int ii = 0;
    while (ii < 6){
        int jj = 2*ii;
        if (rxMsg.messageId == qc_rx_id[ii])
        {
           y_QC[jj]= rxData[0];
           y_QC[jj+1]= rxData[1];
           if (ii < 2){
//               y_QC_alt[j]= rxData[0];
               sensed_qc[0] = 1;
           }
           sensed_qc[1] = 1;
//           printf("rx qc sensor data %x = %u  at %d\n", rxMsg.messageId, y_QC, i);
    //       clock_t start = clock();
    //       CanBasicDemo_run2();
    //       clock_t end = clock();
    //       unsigned long dur = (end-start);
    //       printf("wcet ttc: %ld s\n",dur);
        }
        ii = ii+1;
    }

//    printf("sba_ct = %d at %d\n",sba_ct,i);
    /* for sba dtc */
//    if (rxMsg.messageId == ttc_tx_id)
//    {
////        printf("rx ttc ctrl data id %x at %d\n",rxMsg.messageId,i);
//        int skipped = css_qc[(curIdx_qc-1) % ct_qc];
////        sba_dtc(skipped);
//    }else if (rxMsg.messageId == qc_tx_id )
//    {
//        int skipped = css_qc_alt[(curIdx_qc_alt-1) % ct_qc_alt];
////        sba_dtc(skipped);
//    }else if (rxMsg.messageId == cc_tx_id )
//    {
////        printf("rx cc ctrl data id %x at %d\n",rxMsg.messageId,i);
////        ct_qc_alt = HP / ttc_h_set[task_per[2]];
//        int skipped = css_cc[(curIdx_cc-1) % ct_cc];
////        sba_dtc(skipped);
//    }else if (rxMsg.messageId == sc_tx_id )
//    {
////        printf("rx sc ctrl data id %x at %d\n",rxMsg.messageId,i);
////        ct_qc_alt = HP / ttc_h_set[task_per[3]];
//        int skipped = css_sc[(curIdx_sc-1) % ct_sc];
////        sba_dtc(skipped);
//    }else if (rxMsg.messageId == abs_tx_id )
//    {
////        printf("rx sc ctrl data id %x at %d\n",rxMsg.messageId,i);
////        ct_qc_alt = HP / ttc_h_set[task_per[3]];
//        int skipped = css_abs[(curIdx_abs-1) % ct_abs];
////        sba_dtc(skipped);
//    }
    /* test */
    /*
    uint32 id = 0xc4;
    if (rxMsg.messageId == id)
    {
        printf("rx id %x at %d\n",rxMsg.messageId,i);
    }
    */
}


/* transmission strategy for non-premtive schedule */
int gcd(int a, int b){
//    printf("\t\t inside gcd of a=%d,b=%d\n",a,b);
    if (b == 0)
        return a;
    else
        return gcd(b ,a%b);
}


int lcm(int a, int b){
//    printf("\t inside lcm of a=%d,b=%d\n",a,b);
    return a*b/gcd(a,b);
}


int hp(){
//    updateutil();
    printf("hyperperiod calc= %d\n", HP);
    int a = h_list[0][task_per[0]];
    int b = h_list[1][task_per[1]];
    int H = lcm(a, b);
//    a = h_list[task_per[2]];
//    b = h_list[task_per[3]];
//    H = lcm(H, a);
//    H = lcm(H, b);
    ct_qc = HP / h_list[1][task_per[1]];
    /*
    int j = ct_qc_alt;
    while (j--> 0){
    printf("css for = %d-th instance of the task 0\n",j);
        int per = h_list[task_per[0]];
        css_qc_alt[j] = 1;//qc_subsys[per][k];
    }
    */
    ct_qc_alt = HP / h_list[0][task_per[0]];
    /*
    j = ct_qc;
    while (j--> 0){
        printf("css for = %d-th instance of the task 1\n",j);
        int per = ttc_h_set[task_per[1]];
        css_qc[j] = 1;//qc_subsys[per][k];
    }
    */
//    ct_cc = HP / cc_h_set[task_per[2]];
    /*
    j = ct_cc;
    while (j--> 0){
        printf("css for = %d-th instance of the  task 2\n",j);
        int per = cc_h_set[task_per[2]];
        css_cc[j] = 1;//qc_subsys[per][k];
    }
    */
//    ct_sc = HP / sc_h_set[task_per[3]];
    /*
    j = ct_sc;
    while (j--> 0){
        printf("css for = %d-th instance of the task 3\n",j);
        int per = sc_h_set[task_per[3]];
        css_sc[j] = 1;//qc_subsys[per][k];
    }
    */
    return H;
}


//float calcUtil(int h, int acess, int HP, float wcet){
//     int ct = HP/h;
//     float util = 0;
//     int ii = 0;
//     while (ii < ct){
//         util = util + acess[ii]*wcet;
//     }
//     return util/HP;
//}


void updateutil(){
    int jj = 0;
    int kk = 0;
    while(jj < 2){
       if (jj == 0){
           float Q[4][4] = {{100,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}};
           float R[2][2] = {{10,0},{0,0}};
           J[jj] = 0;
           int ii = 0;
           while (ii < 4){
               J[jj]  = J[jj] + Q[ii][ii]*y_QC[ii]*y_QC[ii];
               ii = ii+1;
           }
           ii = 0;
           while (ii < 2){
              J[jj]  = J[jj] + R[ii][ii]*u_QC_alt[ii]*u_QC_alt[ii];
              ii = ii+1;
          }
           printf("current cost of qc task = %f at i = %d\n",J[0], i);
           if (J[0] > J_ub[jj]){
                   if (task_acess[0] > 0){
//                   if (task_per[jj] > 0){
//                       task_per[jj] -- ;
                       task_acess[0]--;
                   }
               printf("more cost : task 1 alt\n");
           }else if (J[0] < J_lb[jj]){
               if (task_acess[0] < task_access_ct[0]){
                          task_acess[0]++;
                      }
//                   if (task_per[jj] < qc_h_ct)
//                       task_per[jj] ++ ;
               printf("less cost : task 1 alt\n");
           }else{
               printf("ok cost : task 1 alt\n");
           }

//           css_qc_alt[20] =  altlist[task_acess[0]];
           task_per[0] = task_acess[0];
           ct_qc_alt = lens_alt_list[task_acess[0]];
           int kk = 0;
           while ( kk< ct_qc_alt){
               css_qc_alt[kk] = altlist[task_acess[0]][kk];
               kk++;
           }
           printf("new periodicity of esp task = %d at i = %d\n",task_per[jj], i);
       }
       if (jj == 1){
          float Q[12][12] = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
          float R[4][4] = {{1, 0, 0, 0},{0, 10, 0, 0},{0, 0, 10, 0},{0, 0, 0, 10}};
          J[jj] = 0;
          int ii = 0;
          while (ii < 12){
              J[jj]  = J[jj] + Q[ii][ii]*y_QC[ii]*y_QC[ii];
              ii = ii+1;
          }
          ii = 0;
          while (ii < 4){
             J[jj]  = J[jj] + R[ii][ii]*u_QC[ii]*u_QC[ii];
             ii = ii+1;
         }
          printf("current cost of esp task = %f at i = %d\n",J[0], i);
          if (J[0] > J_ub[jj]){
//                   if (task_per[jj] > 0)
//                       task_per[jj] -- ;
              printf("more cost: task 2\n");
          }else if (J[0] < J_lb[jj]){
//                   if (task_per[jj] < qc_h_ct)
//                       task_per[jj] ++ ;
              printf("less cost : task 2\n");
          }else{

              printf("ok cost : task 2\n");
          }
//          css_qc =  trajlist[task_acess[1]];
          task_per[1] = task_acess[1];
          ct_qc = lens_traj_list[task_acess[1]];
          int kk = 0;
          while ( kk< ct_qc){
              css_qc_alt[kk] = trajlist[task_acess[0]][kk];
              kk++;
          }
          printf("new periodicity of qc task = %d at i = %d\n",task_per[jj], i);
      }
       jj++;
    }
}
//*/

void t8_tx()/* h = 10ms*/
{
    int i = 0;
//    printf("task with per = 10ms tx started\n");

    while(i < 2){//for (int i = 0; i++; i < task_ct){

       if (i == 0 && h_list[i][task_per[i]]==8){

           if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc_alt();
                   sensed_qc[0] = 0;
//               }
               CanBasicDemo_tx(txQc1, txDataQC_alt, qc_tx_id[0], qc_tx_buf[0]);
//               CanBasicDemo_tx(txQc2, txDataQC_alt, qc_tx_id[1], qc_tx_buf[1]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }

       }else if (i == 1 && h_list[i][task_per[i]]==8){
           if (css_qc[(curIdx_qc)  % ct_qc]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc();
                   sensed_qc[1] = 0;
//               }
//               CanBasicDemo_tx(txQc2, txDataQC1, qc_tx_id[1], qc_tx_buf[1]);
               CanBasicDemo_tx(txQc3, txDataQC2, qc_tx_id[2], qc_tx_buf[2]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }
       }else {

       }
//       IfxCan_Message txMsg1;
//       uint32 txData1[2];
//       IfxCan_Can_initMessage(&txMsg1);
//       txMsg1.messageId = qc_tx_id;
//       txMsg1.bufferNumber = qc_tx_buf;
//       while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//       printf("tx id %x\n",txMsg1.messageId);
       i++;
   }
}


void t10_tx()/* h = 10ms*/
{
    int i = 0;
//    printf("task with per = 10ms tx started\n");

    while(i < 2){//for (int i = 0; i++; i < task_ct){

       if (i == 0 && h_list[i][task_per[i]]==10){

           if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc_alt();
                   sensed_qc[0] = 0;
//               }
               CanBasicDemo_tx(txQc1, txDataQC_alt, qc_tx_id[0], qc_tx_buf[0]);
//               CanBasicDemo_tx(txQc2, txDataQC_alt, qc_tx_id[1], qc_tx_buf[1]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }

       }else if (i == 1 && h_list[i][task_per[i]]==10){
           if (css_qc[(curIdx_qc)  % ct_qc]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc();
                   sensed_qc[1] = 0;
//               }
//               CanBasicDemo_tx(txQc2, txDataQC1, qc_tx_id[1], qc_tx_buf[1]);
               CanBasicDemo_tx(txQc3, txDataQC2, qc_tx_id[2], qc_tx_buf[2]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }
       }else {

       }
//       IfxCan_Message txMsg1;
//       uint32 txData1[2];
//       IfxCan_Can_initMessage(&txMsg1);
//       txMsg1.messageId = qc_tx_id;
//       txMsg1.bufferNumber = qc_tx_buf;
//       while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//       printf("tx id %x\n",txMsg1.messageId);
       i++;
   }
}


void t20_tx()/* h = 20ms*/
{
    int i = 0;
//    printf("task with per = 10ms tx started\n");

    while(i < 2){//for (int i = 0; i++; i < task_ct){

       if (i == 0 && h_list[i][task_per[i]]==20){

           if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc_alt();
                   sensed_qc[0] = 0;
//               }
               CanBasicDemo_tx(txQc1, txDataQC_alt, qc_tx_id[0], qc_tx_buf[0]);
//               CanBasicDemo_tx(txQc2, txDataQC_alt, qc_tx_id[1], qc_tx_buf[1]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }

       }else if (i == 1 && h_list[i][task_per[i]]==20){
           if (css_qc[(curIdx_qc)  % ct_qc]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc();
                   sensed_qc[1] = 0;
//               }
//               CanBasicDemo_tx(txQc2, txDataQC1, qc_tx_id[1], qc_tx_buf[1]);
               CanBasicDemo_tx(txQc3, txDataQC2, qc_tx_id[2], qc_tx_buf[2]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }
       }else {

       }
//       IfxCan_Message txMsg1;
//       uint32 txData1[2];
//       IfxCan_Can_initMessage(&txMsg1);
//       txMsg1.messageId = qc_tx_id;
//       txMsg1.bufferNumber = qc_tx_buf;
//       while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//       printf("tx id %x\n",txMsg1.messageId);
       i++;
   }
}


void t30_tx()/* h = 30ms*/
{
    int i = 0;
//    printf("task with per = 10ms tx started\n");

    while(i < 2){//for (int i = 0; i++; i < task_ct){

       if (i == 0 && h_list[i][task_per[i]]==30){

           if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc_alt();
                   sensed_qc[0] = 0;
//               }
               CanBasicDemo_tx(txQc1, txDataQC_alt, qc_tx_id[0], qc_tx_buf[0]);
//               CanBasicDemo_tx(txQc2, txDataQC_alt, qc_tx_id[1], qc_tx_buf[1]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }

       }else if (i == 1 && h_list[i][task_per[i]]==30){
           if (css_qc[(curIdx_qc)  % ct_qc]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc();
                   sensed_qc[1] = 0;
//               }
//               CanBasicDemo_tx(txQc2, txDataQC1, qc_tx_id[1], qc_tx_buf[1]);
               CanBasicDemo_tx(txQc3, txDataQC2, qc_tx_id[2], qc_tx_buf[2]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }
       }else {

       }
//       IfxCan_Message txMsg1;
//       uint32 txData1[2];
//       IfxCan_Can_initMessage(&txMsg1);
//       txMsg1.messageId = qc_tx_id;
//       txMsg1.bufferNumber = qc_tx_buf;
//       while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//       printf("tx id %x\n",txMsg1.messageId);
       i++;
   }
}


void t40_tx()/* h = 40ms*/
{
    int i = 0;
//    printf("task with per = 10ms tx started\n");

    while(i < 2){//for (int i = 0; i++; i < task_ct){

       if (i == 0 && h_list[i][task_per[i]]==40){

           if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc_alt();
                   sensed_qc[0] = 0;
//               }
               CanBasicDemo_tx(txQc1, txDataQC_alt, qc_tx_id[0], qc_tx_buf[0]);
//               CanBasicDemo_tx(txQc2, txDataQC_alt, qc_tx_id[1], qc_tx_buf[1]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }

       }else if (i == 1 && h_list[i][task_per[i]]==40){
           if (css_qc[(curIdx_qc)  % ct_qc]){
//               if (sensed_qc[i]){
                   CanBasicDemo_run_qc();
                   sensed_qc[1] = 0;
//               }
               CanBasicDemo_tx(txQc2, txDataQC1, qc_tx_id[1], qc_tx_buf[1]);
               CanBasicDemo_tx(txQc3, txDataQC2, qc_tx_id[2], qc_tx_buf[2]);
    //           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
    //           printf("%d th task with per = 10ms successfully completed\n",i);
           }
       }else {

       }
//       IfxCan_Message txMsg1;
//       uint32 txData1[2];
//       IfxCan_Can_initMessage(&txMsg1);
//       txMsg1.messageId = qc_tx_id;
//       txMsg1.bufferNumber = qc_tx_buf;
//       while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//       printf("tx id %x\n",txMsg1.messageId);
       i++;
   }
}


//void t50_tx()/* h = 50ms */
//{
//    int i = task_ct;
////    printf("task with per = 50ms tx started\n");
//    while(i-->=0){//for (int i = 0; i++; i < task_ct){
//
////        printf("50ms task %d\n",i);
//
//        if (i == 0 && h_list[task_per[i]]==50){
//            if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//                if (sensed_qc_alt){
//                CanBasicDemo_run_qc_alt();
//                sensed_qc_alt = 0;
//                }
//                CanBasicDemo_tx(txEsp, txDataEsp, qc_tx_id, qc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 50ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 1 && ttc_h_set[task_per[i]]==50){
//            if (css_qc[(curIdx_qc)  % ct_qc]){
//                if (sensed_qc){
//                    CanBasicDemo_run_qc();
//                    sensed_qc = 0;
//                }
//                CanBasicDemo_tx(txTtc, txDataTtc, ttc_tx_id, ttc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 50ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 2 && cc_h_set[task_per[i]]==50){
//            if (css_cc[(curIdx_cc)  % ct_cc]){
//                if (sensed_cc){
//                    CanBasicDemo_run_cc();
//                    sensed_cc = 0;
//                }
//                CanBasicDemo_tx(txCc, txDataCc, cc_tx_id, cc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 50ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 3 && sc_h_set[task_per[i]]==50){
//            if (css_sc[(curIdx_sc)  % ct_sc]){
//                if (sensed_sc){
//                    CanBasicDemo_run_sc();
//                    sensed_sc = 0;
//                }
//                CanBasicDemo_tx(txSc, txDataSc, sc_tx_id, sc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 50ms successfully completed\n",i);
//            }else{}
//
//        }else {
//
//
//        }
//    }
////    printf("task 50ms successfully completed\n");
//}
//
//
//void t80_tx()/* h = 80ms */
//{
//    int i = task_ct;
////    printf("task with per = 80ms tx started\n");
//    while(i-->=0){//for (int i = 0; i++; i < task_ct){
//
////        printf("80ms task %d\n",i);
//
//        if (i == 0 && h_list[task_per[i]]==80){
//            if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//                if (sensed_qc_alt){
//                CanBasicDemo_run_qc_alt();
//                sensed_qc_alt = 0;
//                }
//                CanBasicDemo_tx(txEsp, txDataEsp, qc_tx_id, qc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 80ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 1 && ttc_h_set[task_per[i]]==80){
//            if (css_qc[(curIdx_qc)  % ct_qc]){
//                if (sensed_qc){
//                    CanBasicDemo_run_qc();
//                    sensed_qc = 0;
//                }
//                CanBasicDemo_tx(txTtc, txDataTtc, ttc_tx_id, ttc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 80ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 2 && cc_h_set[task_per[i]]==80){
//            if (css_cc[(curIdx_cc)  % ct_cc]){
//                if (sensed_cc){
//                    CanBasicDemo_run_cc();
//                    sensed_cc = 0;
//                }
//                CanBasicDemo_tx(txCc, txDataCc, cc_tx_id, cc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 80ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 3 && sc_h_set[task_per[i]]==80){
//            if (css_sc[(curIdx_sc)  % ct_sc]){
//                if (sensed_sc){
//                    CanBasicDemo_run_sc();
//                    sensed_sc = 0;
//                }
//                CanBasicDemo_tx(txSc, txDataSc, sc_tx_id, sc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 80ms successfully completed\n",i);
//            }else{}
//
//        }else {
//
//
//
//        }
//    }
////    printf("task 80ms successfully completed\n");
//}
//
//
//void t100_tx()/* h = 100ms */
//{
//    int i = task_ct;
////    printf("task with per = 100ms tx started\n");
//    while(i-->=0){//for (int i = 0; i++; i < task_ct){
//
////        printf("100ms task %d\n",i);
//
//        if (i == 0 && h_list[task_per[i]]==10){
//            if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//                if (sensed_qc_alt){
//                CanBasicDemo_run_qc_alt();
//                sensed_qc_alt = 0;
//                }
//                CanBasicDemo_tx(txEsp, txDataEsp, qc_tx_id, qc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 100ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 1 && ttc_h_set[task_per[i]]==100){
//            if (css_qc[(curIdx_qc)  % ct_qc]){
//                if (sensed_qc){
//                    CanBasicDemo_run_qc();
//                    sensed_qc = 0;
//                }
//                CanBasicDemo_tx(txTtc, txDataTtc, ttc_tx_id, ttc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 100ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 2 && cc_h_set[task_per[i]]==100){
//            if (css_cc[(curIdx_cc)  % ct_cc]){
//                if (sensed_cc){
//                    CanBasicDemo_run_cc();
//                    sensed_cc = 0;
//                }
//                CanBasicDemo_tx(txCc, txDataCc, cc_tx_id, cc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 100ms successfully completed\n",i);
//            }else{}
//
//        }else if (i == 3 && sc_h_set[task_per[i]]==100){
//            if (css_sc[(curIdx_sc)  % ct_sc]){
//                if (sensed_sc){
//                    CanBasicDemo_run_sc();
//                    sensed_sc = 0;
//                }
//                CanBasicDemo_tx(txSc, txDataSc, sc_tx_id, sc_tx_buf);CanBasicDemo_tx(txSc, txDataSc, sc_tx_id, sc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 100ms successfully completed\n",i);
//            }else{}
//        }else {
//
//
//
//        }
//    }
////    printf("task 100ms successfully completed\n");
//}
//
//
//void t120_tx()/* h = 120ms */
//{
//    int i = task_ct;
////    printf("task with per = 120ms tx started\n");
//    while(i-->=0){//for (int i = 0; i++; i < task_ct){
//
////        printf("120ms task %d\n",i);
//
//        if (i == 0 && h_list[task_per[i]]==120){
//            if (css_qc_alt[(curIdx_qc_alt)  % ct_qc_alt]){
//                if (sensed_qc_alt){
//                CanBasicDemo_run_qc_alt();
//                sensed_qc_alt = 0;
//                }
//                CanBasicDemo_tx(txEsp, txDataEsp, qc_tx_id, qc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 120ms successfully tx\n",i);
//            }else{}
//
//        }else if (i == 1 && ttc_h_set[task_per[i]]==120){
//            if (css_qc[(curIdx_qc)  % ct_qc]){
//                if (sensed_qc){
//                    CanBasicDemo_run_qc();
//                    sensed_qc = 0;
//                }
//                CanBasicDemo_tx(txTtc, txDataTtc, ttc_tx_id, ttc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 120ms successfully tx\n",i);
//            }else{}
//
//        }else if (i == 2 && cc_h_set[task_per[i]]==120){
//            if (css_cc[(curIdx_cc)  % ct_cc]){
//                if (sensed_cc){
//                    CanBasicDemo_run_cc();
//                    sensed_cc = 0;
//                }
//                CanBasicDemo_tx(txCc, txDataCc, cc_tx_id, cc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 120ms successfully tx\n",i);
//            }else{}
//
//        }else if (i == 3 && sc_h_set[task_per[i]]==120){
//            if (css_sc[(curIdx_sc)  % ct_sc]){
//                if (sensed_sc){
//                    CanBasicDemo_run_sc();
//                    sensed_sc = 0;
//                }
//                CanBasicDemo_tx(txSc, txDataSc, sc_tx_id, sc_tx_buf);
//    //            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//    //            printf("%d th task with per = 120ms successfully tx\n",i);
//            }else{}
//        }else {
//
//
//        }
//    }
////    printf("task 120ms successfully completed\n");
//}
//

void t7_busload(int a)
{
    //core_0_online=1;


    uint32 ID[5]= {0x230,0x323,0x90,0x98,0x500};


    uint32 txData1[2];
    uint32 txData2[2];
    uint32 txData3[2];
    uint32 txData4[2];
    uint32 txData5[2];

    IfxCan_Message txMsg1;
    IfxCan_Can_initMessage(&txMsg1);
    txMsg1.messageId = ID[0];
    txMsg1.bufferNumber = 13;


    IfxCan_Message txMsg2;
       IfxCan_Can_initMessage(&txMsg2);
       txMsg2.messageId = ID[1];
       txMsg2.bufferNumber = 14;


       IfxCan_Message txMsg3;
          IfxCan_Can_initMessage(&txMsg3);
          txMsg3.messageId = ID[2];
          txMsg3.bufferNumber = 15;



          IfxCan_Message txMsg4;
             IfxCan_Can_initMessage(&txMsg4);
             txMsg4.messageId = ID[3];
             txMsg4.bufferNumber = 16;


             IfxCan_Message txMsg5;
             IfxCan_Can_initMessage(&txMsg5);
             txMsg5.messageId = ID[4];
             txMsg5.bufferNumber = 17;


             dummy_comp1();
             txData1[0] = txData2[0]= txData3[0]=txData4[0]=txData5[0]= 100+i;
             txData1[1] = txData2[1] = txData3[1] = txData4[1] = txData5[1] = 0;

             if (a == 1)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
             else if(a == 2)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg2, txData2) == IfxCan_Status_notSentBusy);
             else if(a == 3)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg3, txData3) == IfxCan_Status_notSentBusy);
             else if(a == 4)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg4, txData4) == IfxCan_Status_notSentBusy);
             else if(a == 5)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg5, txData5) == IfxCan_Status_notSentBusy);
             else {
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
                 dummy_comp1();
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg2, txData2) == IfxCan_Status_notSentBusy);
                 dummy_comp1();
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg3, txData3) == IfxCan_Status_notSentBusy);
                 dummy_comp1();
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg4, txData4) == IfxCan_Status_notSentBusy);
                 dummy_comp1();
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg5, txData5) == IfxCan_Status_notSentBusy);
             }



//    printf("task 700 successfully completed\n");
}


/* Macro to define the Interrupt Service Routine. */
IFX_INTERRUPT(interruptGtmTom, 0, ISR_PRIORITY_TOM);
/* transmission strategy for non-preemptive schedule */

int slot_id = 0;

/* Interrupt Service Routine of the TOM */
void interruptGtmTom(void)
{
    /* hns test */
    /*
    if(allinst == 10){
        core_1_online = 1;
        allinst = 0;
//        inst = 0;
    }
    */

    /* transmission strategy for non-preemptive schedule */
    /*
    int last = task_sequence4[slot_id];
    int next = task_sequence4[slot_id+1];

    if (slot_id==599)
    {
        next = 0;
    }

    if (slot_id==600)
    {
        slot_id=0;
        tx = 0;
    }

//    CanBasicDemo_run2(void);

    int tx = ((last - next) != 0)? 1: 0;
    task_scheduler(task_sequence4[slot_id],tx,ex);
    */
//    if (slot_id==600)
//    clock_t now = clock();
//    unsigned long dur1 = (now-last);
//    last = now;
//    printf("At %d clock pulse spent  %ld \n", i,dur1);
//    BO_ISR();
    i = i+1;
//    t10_tx();
    if (slot_id % 2 == 0)//0.003--100freq,clk1
    {
            t8_tx();
//            t7_busload(5);
    }
    if (slot_id % 3 == 0)//0.01--100freq,clk1
    {

//        t12_5_tx();//---
//        int ii = 20;
//        while(ii>0){
//            dummy_comp1();
//            ii--;
//        }
        t10_tx();
//        t7_busload(1);
//        ii = 70;
//        while(ii>0){
//            dummy_comp1();
//            ii--;
//        }
    }
    if (slot_id % 6 == 0)//0.02--100freq,clk1
    {
//        int ii = 20;
//        while(ii>0){
//            dummy_comp1();
//            ii--;
//        }
            t20_tx();
//            t3_transmission();
//            t7_busload(1);
//            ii = 70;
//            while(ii>0){
//                dummy_comp1();
//                ii--;
//            }
    }
    if (slot_id % 8 == 0)/* < 0.025 */
    {
//        t25_tx();
    }
    if (slot_id % 10 == 0)/* < 0.025 */
    {
        t30_tx();
    }
    if (slot_id % 12 == 0)//0.04--100freq,clk1
    {
//        dummy_comp1();
            t40_tx();
//            t3_transmission();
//            t7_busload(2);
//            int ii = 50;
//            while(ii>0){
//                dummy_comp1();
//                ii--;
//            }
    }
    if (slot_id % 15 == 0)//0.05--100freq,clk1
    {
//        t2_brakes();//task_scheduler(200);/* brakes */
//        t4_qc();//task_scheduler(100);/* ttc */
//        int ii = 50;
//        while(ii>0){
//            dummy_comp1();
//            ii--;
//        }
//        t50_tx();
//        ii = 50;
//        while(ii>0){
//            dummy_comp1();
//            ii--;
//        }
//        t80_tx();
//        dummy_comp1();
    }
    if (slot_id % 24 == 0){//0.08--100freq,clk1

//        t80_tx();
//        printf("80 ms task\n");
    }
    if (slot_id % 40 == 0){/* 0.1 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        dummy_comp1();
//        t100_tx();
//        printf("hp = %d\n",hp());
//        t7_busload(3);
    }
    if (slot_id % 43 == 0){/* 0.12 */

//        t120_tx();
//        t7_busload(4);
//        printf("120 ms task\n");
    }
    if (slot_id % 75 == 0){/* 0.25 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        t250_tx();//----
    }
    if (slot_id % 160 == 0){/* 0.5 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        t500_tx();//----
    }
    if (slot_id % 303 == 0){/* 1 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        t1000_tx();
//        t1000_tx2();//----
//        t7_busload(5);
    }
//    if (slot_id % 24 == 0){/* 0.08 */
//        task_scheduler(200);/* brakes */
//        task_scheduler(100);/* ttc */
//    }
    /* reset at hyper period */
    slot_id=slot_id+1;
    if (slot_id % 7 == 0){/* 0.02 *///
        if(HP==20){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
            slot_id = 1;
            updateutil();
            HP =hp();
        }

    }else if (slot_id % 13 == 0){/* 0.04 *///
        if(HP==40){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
            slot_id = 1;
            updateutil();
            HP = hp();
        }

    }else if (slot_id % 15 == 0){/* 0.05*/
        if(HP==50){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
       }

    }else if (slot_id % 27 == 0){/* 0.08 */
        if(HP==80){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
       }

    }else if (slot_id % 30 == 0){/* 0.1 */
        if(HP==100){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
       }

    }else if (slot_id % 40 == 0){/* 0.12 */
        if(HP==120){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
       }

    }else if (slot_id % 61 == 0){/* 0.2 */
        if(HP==200){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
       }

    }else if (slot_id % 71 == 0){/* 0.24 */
        if(HP==240){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
        }

    }else if (slot_id % 120 == 0){/* 0.4 */
        if(HP==400){
           printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP = hp();
       }
    }
    else if (slot_id % 304 == 0){/* 1 */
        if(HP==1000){
            printf("resetting slot_id=%d at i=%d\n",slot_id,i);
            slot_id = 1;
            updateutil();
            HP = hp();
        }
//        task_scheduler(200);
    }else if (slot_id % 356 == 0){/* 1.2 */
        if(HP==1200){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           updateutil();
           HP =hp();
       }
    }
//    if (slot_id % 290){/* 1s */
//        t1000_tx();
//        slot_id=0;
//    }
//    printf("clock at i=\n",i);
//    if(done == 1){
//        printf("done still one\n");
//        i = i+1;
//    }else if(done == 0){
//        i= 0;
//    }
//    task_scheduler(task_sequence4[slot_id]);
//    IfxAsclin_Asc_isrTransmit(&g_asc);

    /* control tasks */
//    if (sensed_qc){
//        CanBasicDemo_run_qc();
//        sensed_qc = 0;
//    }
//    if (sensed_qc_alt){
//        CanBasicDemo_run_qc_alt();
//        sensed_qc_alt = 0;
//    }
    IfxGtm_Tom_Timer_acknowledgeTimerIrq (&g_timerDriver);  /* Clear the timer event */
}

/* This function initializes the TOM */
void initGtmTom(void)
{
    IfxGtm_enable(&MODULE_GTM); /* Enable GTM */
    g_tickFor3ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);
    /* TOM */
    IfxGtm_Tom_Timer_Config timerConfig;                                        /* Timer configuration              */
    IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);                     /* Initialize timer configuration   */

    timerConfig.base.frequency       = TOM_FREQ;                                /* Set timer frequency              */
    timerConfig.base.isrPriority     = ISR_PRIORITY_TOM;                        /* Set interrupt priority           */
    timerConfig.base.isrProvider     = IfxSrc_Tos_cpu0;                         /* Set interrupt provider           */
    timerConfig.tom                  = IfxGtm_Tom_1;                            /* Define the timer used            */
    timerConfig.timerChannel         = IfxGtm_Tom_Ch_0;                         /* Define the channel used          */
    timerConfig.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk3;          /* Define the CMU clock used        */

    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);               /* Enable the CMU clock             */
    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);                        /* Initialize the TOM               */

    //IfxPort_setPinModeOutput(LED1, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);  /* Set pin mode         */
    //IfxPort_setPinModeOutput(LED2, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    IfxGtm_Tom_Timer_run(&g_timerDriver);                                       /* Start the TOM                    */
    last = clock();
}
/*******************************************************
///* Macro to define the Interrupt Service Routine. */
//IFX_INTERRUPT(interruptGtmTom1, 0, ISR_PRIORITY_TOM1);
//
//int slot_id_1 = 0;
//
///* Interrupt Service Routine of the TOM_1 */
//void interruptGtmTom1(void)
//{
////    BO_ISR();
////    i = i+1;
//
//    if (slot_id_1 % 2 == 0)/* 0.0125 */
//    {
//            t12_5_tx();
//    }
//    if (slot_id % 4 == 0)/* 0.025 *///tom 1
//    {
//        t25_tx();
//    }
//    slot_id_1 = slot_id_1+1;
//    if (slot_id_1 == 8){
//        slot_id_1=0;
//    }
//    IfxGtm_Tom_Timer_acknowledgeTimerIrq (&g_timerDriver1);  /* Clear the timer event */
//}
//
///* This function initializes the TOM */
//void initGtmTom1(void)
//{
//    IfxGtm_enable(&MODULE_GTM); /* Enable GTM */
//    g_tickFor3ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);
//    /* TOM 1 */
//    IfxGtm_Tom_Timer_Config timerConfig1;                                       /* Timer configuration              */
//    IfxGtm_Tom_Timer_initConfig(&timerConfig1, &MODULE_GTM);                    /* Initialize timer configuration   */
//
//    timerConfig1.base.frequency       = TOM_FREQ_1;                             /* Set timer frequency              */
//    timerConfig1.base.isrPriority     = ISR_PRIORITY_TOM1;                      /* Set interrupt priority           */
//    timerConfig1.base.isrProvider     = IfxSrc_Tos_cpu0;                        /* Set interrupt provider           */
//    timerConfig1.tom                  = IfxGtm_Tom_1;                           /* Define the timer used            */
//    timerConfig1.timerChannel         = IfxGtm_Tom_Ch_0;                        /* Define the channel used          */
//    timerConfig1.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk1;         /* Define the CMU clock used        */
//
//    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);               /* Enable the CMU clock             */
//    IfxGtm_Tom_Timer_init(&g_timerDriver1, &timerConfig1);                      /* Initialize the TOM               */
//
//    //IfxPort_setPinModeOutput(LED1, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);  /* Set pin mode         */
//    //IfxPort_setPinModeOutput(LED2, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
//
//    IfxGtm_Tom_Timer_run(&g_timerDriver1);                                       /* Start the TOM_1                    */
//    last = clock();
//}
//*****************************************************************/
/* interrupt to raise when bus-off*/
//IFX_INTERRUPT(BO_ISR, 0, ISR_PRIORITY_CAN1_BO);
//
void BO_ISR(void)
{
    Ifx_CAN   *canSfr =  &MODULE_CAN1;
    Ifx_CAN_N* node = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
    boolean isbusoff = IfxCan_Node_getBusOffStatus(node);//CAN0_PSR0.B.BO;
    boolean warning = IfxCan_Node_getWarningStatus(node);//CAN0_PSR0.B.EW;
//    IfxCan_Status status;
    /* rx reset msg */
    /*
    uint32 txData[2];
    IfxCan_Message txMsg;
    IfxCan_Can_initMessage(&txMsg);
    txMsg.messageId = sba_dtc_tx_id;
    txMsg.bufferNumber = sba_dtc_tx_buf;//2;
    txMsg.dataLengthCode = IfxCan_DataLengthCode_8;
    txData[0] = node->ECR.B.CEL;//node->ECR.B.TEC; //CAN1_ECR0.B.TEC;
    txData[1] = 0;
    */
    if (warning){
//        printf("TEC: %u, busoff status : %d, and detection count : %d at %d\n",CAN1_ECR0.B.TEC, isbusoff, sba_ct, i);
//        printf("TEC: %u, busoff status : %d, and detection count : %d at %d\n",node->ECR.B.TEC, isbusoff, sba_ct, i);
//        while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData) == IfxCan_Status_notSentBusy);
    }
    if(isbusoff)
    {
        IfxCan_Node_clearInterruptFlag(node,IfxCan_Interrupt_busOffStatus);
        node->CCCR.B.INIT = 0; // clearing to reinit
        printf("reset from busoff\n");
    }
}

/* ----- for tx --------*/
void CanBasicDemo_tx(IfxCan_Message txMsg, uint32 *txDataMsg, uint32 msg_tx_id, uint8 msg_tx_buf)
{
    IfxCan_Can_initMessage(&txMsg);
    txMsg.messageId = msg_tx_id;
    txMsg.bufferNumber = msg_tx_buf;
    printf("--tx id= %u at %d\n", txMsg.messageId, i);
    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txDataMsg) == IfxCan_Status_notSentBusy);
}


void CanBasicDemo_init(void)
{
    IfxScuCcu_Config IfxScuCcuConfig;

    /* interrupt groups configuration */
    volatile Ifx_SRC_SRCR *srcPointer;
    /* disable interrupts */
    boolean  interruptState = IfxCpu_disableInterrupts();

    /* Default clock initialisation */
    IfxScuCcu_initConfig(&IfxScuCcuConfig);
    IfxScuCcu_init(&IfxScuCcuConfig);

    /* CAN0 initilisation */
    {
        /* create module configuration */
        IfxCan_Can_Config canConfig;
        IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN0);

        /* initialize module */
        IfxCan_Can_initModule(&g_CanBasic.drivers.can[0], &canConfig);
    }

    /* CAN1 initilisation */
    {
         /*create module configuration*/
        IfxCan_Can_Config canConfig;
        IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN1);

         /*initialize module*/
        IfxCan_Can_initModule(&g_CanBasic.drivers.can[1], &canConfig);
    }

     /*create node configuration*/

     /*CAN 0 Node0 as receive node*/
    {
        IfxCan_Can_NodeConfig nodeConfig;
        IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanBasic.drivers.can[0]);
        /* for busoff */
        nodeConfig.baudRate.baudrate = 1000000;//500000;//250000;


        nodeConfig.nodeId = IfxCan_NodeId_0;
        nodeConfig.frame.type = IfxCan_FrameType_receive;

        nodeConfig.messageRAM.standardFilterListStartAddress = 0x100;
        nodeConfig.messageRAM.rxBuffersStartAddress          = 0x200;
        nodeConfig.messageRAM.rxFifo0StartAddress            = 0x300;
        nodeConfig.messageRAM.baseAddress                    = (uint32)&MODULE_CAN0;

        nodeConfig.rxConfig.rxMode                           = IfxCan_RxMode_sharedAll;

        nodeConfig.rxConfig.rxFifo0Size                      = 8;
        nodeConfig.rxConfig.rxFifo0OperatingMode             = IfxCan_RxFifoMode_overwrite;

        IfxCan_Can_Pins pins;
        pins.rxPin = &IfxCan_RXD00B_P20_7_IN;
        pins.rxPinMode = IfxPort_InputMode_pullUp;
        pins.txPin = &IfxCan_TXD00_P20_8_OUT;
        pins.txPinMode = IfxPort_OutputMode_pushPull;
        pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
        nodeConfig.pins = &pins;

        /* For interrupt configuration user needs to configure the priority and select one of the 16 interrupt lines*/
//        nodeConfig.interruptConfig.reint.priority = ISR_PRIORITY_CAN0_RX ;
//        nodeConfig.interruptConfig.reint.interruptLine =  IfxCan_InterruptLine_14;
//        nodeConfig.interruptConfig.reint.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

//        Interrupt configuration for Fifo 0
        nodeConfig.interruptConfig.rxf0n.priority = ISR_PRIORITY_CAN0_RX ;
        nodeConfig.interruptConfig.rxf0n.interruptLine =  IfxCan_InterruptLine_14;
        nodeConfig.interruptConfig.rxf0n.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

        IfxCan_Can_initNode(&g_CanBasic.drivers.canNode[0], &nodeConfig);

        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanBasic.drivers.canNode[0].can, nodeConfig.nodeId);

        IfxCan_Node_enableConfigurationChange(nodeSfr);
        /* Enable interrupts in CAN */
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo0NewMessage);
        IfxCan_Node_disableConfigurationChange(nodeSfr);
        printf(" Rx Node Base Address  = %x\n",(unsigned int)g_CanBasic.drivers.canNode[0].node);
    }

    /* CAN 1 Node 0 as transmit node*/
    {
        IfxCan_Can_NodeConfig nodeConfig;
        IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanBasic.drivers.can[1]);

        /* for busoff */
        nodeConfig.baudRate.baudrate = 1000000;//500000;//250000;
        nodeConfig.interruptConfig.busOffStatusEnabled=1;
        nodeConfig.interruptConfig.boff.priority = ISR_PRIORITY_CAN1_BO;
        nodeConfig.interruptConfig.boff.interruptLine = IfxCan_InterruptLine_13;
        nodeConfig.interruptConfig.boff.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());


        //added
        nodeConfig.interruptConfig.protocolErrorArbitrationEnabled=1;
        nodeConfig.interruptConfig.watchdogEnabled=1;
        nodeConfig.interruptConfig.protocolErrorDataEnabled=1;
        //end


        nodeConfig.nodeId = IfxCan_NodeId_0;
        nodeConfig.frame.type = IfxCan_FrameType_transmit;
        nodeConfig.txConfig.dedicatedTxBuffersNumber = 20;

        nodeConfig.messageRAM.txBuffersStartAddress = 0x400;
        nodeConfig.messageRAM.baseAddress           = (uint32)&MODULE_CAN1;

        IfxCan_Can_Pins pins;
        pins.rxPin = &IfxCan_RXD10C_P23_0_IN;
        pins.rxPinMode = IfxPort_InputMode_pullUp;
        pins.txPin = &IfxCan_TXD10_P23_1_OUT;
        pins.txPinMode = IfxPort_OutputMode_pushPull;
        pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
        nodeConfig.pins = &pins;

         /*Enabling interrupts*/
        nodeConfig.interruptConfig.traco.priority  = ISR_PRIORITY_CAN1_TX ;
        nodeConfig.interruptConfig.traco.interruptLine =  IfxCan_InterruptLine_15;
        nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

         /*initialize module*/
        IfxCan_Can_initNode(&g_CanBasic.drivers.canNode[1], &nodeConfig);

        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanBasic.drivers.canNode[1].can, nodeConfig.nodeId);

        IfxCan_Node_enableConfigurationChange(nodeSfr);

        /* Enable interrupts in CAN */
    IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_transmissionCompleted);

    /* disable configuration change CCCR.CCE = 0 */
    IfxCan_Node_disableConfigurationChange(nodeSfr);

        printf(" Tx Node Base Address  = %x\n",(unsigned int)g_CanBasic.drivers.canNode[1].node);
    }

    /* set filters */

    {
        /* Initialise the filter structure */
        IfxCan_Filter filter;

        /* Set a range filter to accept the CAN message with Ids 0x00- 0x7ff*/

        /* set filter0 for rxBuffer 0 */
        filter.number = 0;
        filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
        filter.id1 = 0x00;
        filter.rxBufferOffset = IfxCan_RxBufferId_0;

        IfxCan_Can_setStandardFilter(&g_CanBasic.drivers.canNode[0], &filter);

        /* set filter0 for rxBuffer 1 */
        filter.number = 1;
        filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
        filter.id1 = 0x7FF;
        filter.rxBufferOffset = IfxCan_RxBufferId_1;

        IfxCan_Can_setStandardFilter(&g_CanBasic.drivers.canNode[0], &filter);
    }

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);

    printf("CAN is initialized\n");
//    HP = hp();
}


void CanBasicDemo_run_qc(void)  /*     This is the code of QC     */
{
//    uint32 txData2[2];
    float a[12][12] = {{1, 0.01,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                        {0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                        {0,    0,    1, 0.01,    0,    0,    0,    0,    0,    0,    0,    0},
                        {0,    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0},
                        {0,    0,    0,    0,    1, 0.01,     0.00049,   1.633e-06,    0,    0,    0,    0},
                        {0,    0,    0,    0,    0,    1,       0.098,     0.00049,    0,    0,    0,    0},
                        {0,    0,    0,    0,    0,    0,    1, 0.01,    0,    0,    0,    0},
                        {0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0},
                        {0,    0,    0,    0,    0,    0,    0,    0,    1, 0.01    -0.00049,  -1.633e-06},
                        {0,    0,    0,    0,    0,    0,    0,    0,    0,    1,      -0.098,    -0.00049},
                        {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1, 0.01},
                        {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1}};

    float b[12][4] = {{0.00001, 0, 0, 0},
                        {0.002, 0, 0, 0},
                        {0, 0.000005, 0, 0},
                        {0, 0.001, 0, 0},
                        {0, 0, 0, 0},
                        {0, 0, 0, 0},
                        {0, 0, 0.000005, 0},
                        {0, 0, 0.001, 0},
                        {0, 0, 0, 0},
                        {0, 0, 0, -0.0000001633},
                        {0, 0, 0, 0.000005},
                        {0, 0, 0, 0.001}};

//    float c[12][12] = {{1,0,0,0,0,0,0,0,0,0,0,0},
//                        {0,1,0,0,0,0,0,0,0,0,0,0}
//
//
//    };

//    float d[4][2] = {{0, 0},{0, 0},{0, 0},{0, 0}};

    float K[4][16] = {{3.14451685869324, 5.61640885706677, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                        {0, 0, 0.315827253270447, 2.53304005481979, 0, 0, 0, 0, 0, 0, 0, 0},
                        {0, 0, 0, 0, 3.10787674690884, 6.15027001575052, 59.4853828724422, 34.4066362896555, 0, 0, 0, 0},
                        {0, 0, 0, 0, 0, 0, 0, 0, -3.10787674687785, -6.15027001566358, 59.4853828713107, 34.4066362889244}};

//    float L[4][1] = {{0.627216669816835}, {0.0776672166534822}, {0.0335031868276192}, {0.804439585315085}};
    if (h_list[task_per[1]]==8 || h_list[1][task_per[1]]==40){/*  qc altitude control code  0.008s */
        printf("Acquiring system matrices for task qc alt, periodicity 40\n");
        float K[4][16] = {{3.14806101403323, 5.61958299359191,    -1.06574271596490e-13,   -3.51167300129546e-13,   1.41342271329799e-12,    2.01062101868168e-12,    1.01336113292644e-11,    2.21595181457621e-11,    -6.09240741105249e-14,   5.22728093268344e-16,    -2.29214005150142e-13,   -1.63828525072864e-14},
                         {-1.40612070043267e-13, -1.55665450866325e-13,   0.315907315209643,   2.53336608803131,    6.85283776603311e-13,    8.93097231937326e-13,    5.64678083994045e-12,    1.85029586289379e-12,    2.38846862222207e-13,    3.94653870911855e-13,    -2.69539769628066e-12,   -1.50278419750555e-12},
                         {6.06951163104689e-12,  1.09751533138976e-11,    1.16215441377720e-13,    1.84009321132151e-12,    3.11868152834707,    6.16850483139175,    59.6311710091072,    34.4660711180138,    4.69926930228626e-11,    7.26917658867268e-11,    -5.24662404659150e-10,   -1.89171664196777e-10},
                         {4.93997661255683e-13,  -7.79648124187351e-15,   -3.11282929182986e-13,   -1.50718804881790e-12,   -5.37309119167142e-11,   -7.78148637957717e-11,   -5.41596347348106e-10,   -1.89400019326547e-10,   -3.11868152830212,   -6.16850483132701,   59.6311710086223,    34.4660711178274}};
    }
    else if (h_list[1][task_per[1]]==10){/*  qc altitude control code  0.01s */
        printf("Acquiring system matrices for task qc, periodicity 10\n");
        float a[12][12] =  {{1, 0.01,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    1, 0.01,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    0,    0,    1, 0.01,     0.00049,   1.633e-06,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    1,       0.098,     0.00049,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    1, 0.01,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    0,    0,    1, 0.01    -0.00049,  -1.633e-06},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    1,      -0.098,    -0.00049},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1, 0.01},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1}};

        float b[12][4] =   {{0.00001, 0, 0, 0},
                            {0.002, 0, 0, 0},
                            {0, 0.000005, 0, 0},
                            {0, 0.001, 0, 0},
                            {0, 0, 0, 0},
                            {0, 0, 0, 0},
                            {0, 0, 0.000005, 0},
                            {0, 0, 0.001, 0},
                            {0, 0, 0, 0},
                            {0, 0, 0, -0.0000001633},
                            {0, 0, 0, 0.000005},
                            {0, 0, 0, 0.001}};

//             float c[][] = {{1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1}};
//
//             float d[][] = {{0, 0},{0, 0},{0, 0},{0, 0}};

//        float K[4][16] = {{3.14451685869324, 5.61640885706677, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//                            {0, 0, 0.315827253270447, 2.53304005481979, 0, 0, 0, 0, 0, 0, 0, 0},
//                            {0, 0, 0, 0, 3.10787674690884, 6.15027001575052, 59.4853828724422, 34.4066362896555, 0, 0, 0, 0},
//                            {0, 0, 0, 0, 0, 0, 0, 0, -3.10787674687785, -6.15027001566358, 59.4853828713107, 34.4066362889244}};
        float K[4][16] = {{3.14451685869324, 5.61640885706677, -2.24815378560498e-13, -9.35040910781222e-13, -2.00084615486558e-12, -3.19864871177971e-12, -2.42906164884875e-11, -9.12993173689396e-12, 7.77479339632901e-13, 1.32462155507943e-12, -1.13920607077515e-11, -5.28889409924540e-12},
                          {-2.40306241803692e-13, -4.72815380478954e-13,   0.315827253270447,   2.53304005481979,    7.84605220808760e-13,    1.16425694772151e-12,    8.43874185194031e-12,    3.06879093499489e-12,    -5.31262238867872e-13,   -8.59004682947821e-13,   6.52030942425330e-12,    3.26154527538293e-12},
                          {-3.67448507775373e-12, -4.52413546402716e-12,   -2.93728431368812e-13,   3.14130884398491e-12,    3.10787674690884,    6.15027001575052,    59.4853828724422,    34.4066362896555,    -1.18482368586491e-10,   -2.08120109148284e-10,   1.68577401900408e-09,    6.47292755594409e-10},
                          {-2.45653038076514e-12, -2.62953318968014e-12,   -1.22285655546061e-13,   3.40902909601388e-12,    9.27267520204066e-11,    1.69084002031452e-10,    1.47075073708627e-09,    6.46413943908671e-10,    -3.10787674687785,   -6.15027001566358,   59.4853828713107,    34.4066362889244}};


//           float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

    }else  if (h_list[1][task_per[1]]==20){/*  qc altitude control code  0.02s */
        printf("Acquiring system matrices for task qc, periodicity 20\n");
        float a[12][12] =  {{1, 0.02,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    1, 0.02,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    0,    0,    1, 0.02,     0.00196,   0.00001307,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    1,       0.196,     0.00196,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    1, 0.02,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    0,    0,    1, 0.02,    -0.00196,  -0.00001307},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    1,      -0.196,    -0.00196},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1, 0.02},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1}};

        float b[12][4] = {{0.00004,           0,           0,           0},
                            {0.004,           0,           0,           0},
                            {0,       0.00002,           0,           0},
                            {0,       0.002,            0,           0},
                            {0,           0,            0,           0},
                            {0,           0,   0.000001307,           0},
                            {0,           0,       0.00002,           0},
                            {0,           0,       0.002,           0},
                            {0,           0,           0,           0},
                            {0,           0,           0,  -0.000001307},
                            {0,           0,           0,       0.00002},
                            {0,           0,           0,       0.002}};

//             float c[][] = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
//
//             float d[][] = {{0, 0},{0, 0},{0, 0},{0, 0}};

        float K[4][16] = {{3.12685594967393, 5.60056530879117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                        {0, 0, 0.315427247946649, 2.53141053716782, 0, 0, 0, 0, 0, 0, 0, 0},
                        {0, 0, 0, 0, 3.05441194111679, 6.05997082436238, 58.7631166321155, 34.1120666564246, 0, 0, 0, 0},
                        {0, 0, 0, 0, 0, 0, 0, 0, -3.05441194117077, -6.05997082447233, 58.7631166330827, 34.1120666568239}};

//       float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

    }else if (h_list[1][task_per[1]]==30){/*  qc altitude control code  0.03s */
        printf("Acquiring system matrices for task qc, periodicity 30\n");
        float a[12][12] =  {{0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    1, 0.03,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0},
                            {0,    0,    0,    0,    1, 0.03,    0.00441,   0.0000441,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    1,      0.294,    0.00441,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    1, 0.03,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0},
                            {0,    0,    0,    0,    0,    0,    0,    0,    1, 0.03,   -0.00441,  -0.0000441},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    1,     -0.294,   -0.00441},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1, 0.03},
                            {0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1}};
        float b[12][4] =   {{0, 0, 0, 0},
                            {0.006, 0, 0, 0},
                            {0,     0.000045, 0, 0},
                            {0,      0.003, 0, 0},
                            {0, 0,      0, 0},
                            {0, 0,    0.00000441, 0},
                            {0, 0,     0.000045, 0},
                            {0, 0,       0.003, 0},
                            {0, 0, 0,       0},
                            {0, 0, 0,   -0.00000441},
                            {0, 0, 0,     0.000045},
                            {0, 0, 0,       0.003}};

//             float c[][] = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
//
//             float d[][] = {{0, 0},{0, 0},{0, 0},{0, 0}};

        float K[4][16] = {{3.10929450940453, 5.58476697969132, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                          {0, 0, 0.315027749563069, 2.52978210015362, 0, 0, 0, 0, 0, 0, 0, 0},
                          {0, 0, 0, 0, 3.00186737100001, 5.97111120050923, 58.0518248251535, 33.8217758502374, 0, 0, 0, 0},
                          {0, 0, 0, 0, 0, 0, 0, 0, -3.00186737091428, -5.97111120037752, 58.0518248241734, 33.8217758498679}};


//       float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

    }
    //

//       float check = xA - xhatA;

//          float new_xhat[4][1]={{0},{0},{0},{0}};
            int ii =0;
            while (ii < 12){
                xhat_QC[ii]= ((float)y_QC[ii]/(float)QC_X_FACTOR[ii])-(float)QC_X_OFFSET[ii];//xhat_QC_alt[0];
                ii = ii +1;
            }
//          float y = ((float)y1_QC_alt/(float)QC_XA_factor)-(float)QC_XA_offset;
//          float xB = (xB_P5/(float)P5_XB_factor)-P5_XB_offset;
//          printf("qc sensor data = %u op =  %f at %d\n",y1_QC_alt, xhatA, i);
//          float u = u_QC_alt;
//          new_xhat[0][0]
//                      xhat_QC_alt[0] = a[0][0]*xhatA + a[0][1]*xhatB + a[0][2]*xhatC + a[0][3]*xhatD + u*b[0][0] ;//+ L[0][0]*(y-xhatA);
//          new_xhat[1][0]
//                      xhat_QC_alt[1] = a[1][0]*xhatA + a[1][1]*xhatB + a[1][2]*xhatC + a[1][3]*xhatD + u*b[1][0] ;//+ L[1][0]*(y-xhatA);
//          new_xhat[2][0]
//                      xhat_QC_alt[2] = a[2][0]*xhatA + a[2][1]*xhatB + a[2][2]*xhatC + a[2][3]*xhatD + u*b[2][0] ;//+ L[2][0]*(y-xhatA);
//          new_xhat[3][0]
//                      xhat_QC_alt[3] = a[3][0]*xhatA + a[3][1]*xhatB + a[3][2]*xhatC + a[3][3]*xhatD + u*b[3][0] ;//+ L[3][0]*(y-xhatA);


//            ii = 0;
//            int jj = 0;
//            while(ii < 4){
//                u_QC[ii] = 0;
//                jj = 0;
////                printf("at row = %d\n",ii);
//                while(jj < 12){
////                    printf("at col = %d\n",jj);
//                    u_QC[ii] = u_QC[ii] - K[ii][jj]*(xhat_QC[jj] - QC_REF[jj]);
//                    printf("multiplying K[%d][%d]=%f with xhat[%d]=%f minus %f in u[%d]= %f\n ", ii, jj, K[ii][jj], jj, xhat_QC[jj], QC_REF[jj], ii,  u_QC[ii]);
//                    jj = jj+1;
//                }
//                ii = ii+1;
//            }
            u_QC[0] = -(K[0][0]*(xhat_QC[0]-QC_REF[0]) + K[0][1]*xhat_QC[1] + K[0][2]*xhat_QC[2] + K[0][3]*xhat_QC[3]
                                  + K[0][4]*(xhat_QC[4]-QC_REF[4]) + K[0][5]*xhat_QC[5] + K[0][6]*xhat_QC[6] + K[0][7]*xhat_QC[7]
                                     + K[0][8]*(xhat_QC[8]-QC_REF[8]) + K[0][9]*xhat_QC[9] + K[0][10]*xhat_QC[10] + K[0][11]*xhat_QC[11]);
            u_QC[1] = -(K[1][0]*(xhat_QC[0]-QC_REF[0]) + K[1][1]*xhat_QC[1] + K[1][2]*xhat_QC[2] + K[1][3]*xhat_QC[3]
                                              + K[1][4]*(xhat_QC[4]-QC_REF[4]) + K[1][5]*xhat_QC[5] + K[1][6]*xhat_QC[6] + K[1][7]*xhat_QC[7]
                                                 + K[1][8]*(xhat_QC[8]-QC_REF[8]) + K[1][9]*xhat_QC[9] + K[1][10]*xhat_QC[10] + K[1][11]*xhat_QC[11]);
            u_QC[2] = -(K[2][0]*(xhat_QC[0]-QC_REF[0]) + K[2][1]*xhat_QC[1] + K[2][2]*xhat_QC[2] + K[2][3]*xhat_QC[3]
                                              + K[2][4]*(xhat_QC[4]-QC_REF[4]) + K[2][5]*xhat_QC[5] + K[2][6]*xhat_QC[6] + K[2][7]*xhat_QC[7]
                                                 + K[2][8]*(xhat_QC[8]-QC_REF[8]) + K[2][9]*xhat_QC[9] + K[2][10]*xhat_QC[10] + K[2][11]*xhat_QC[11]);
            u_QC[3] = -(K[3][0]*(xhat_QC[0]-QC_REF[0]) + K[3][1]*xhat_QC[1] + K[3][2]*xhat_QC[2] + K[3][3]*xhat_QC[3]
                                              + K[3][4]*(xhat_QC[4]-QC_REF[4]) + K[3][5]*xhat_QC[5] + K[3][6]*xhat_QC[6] + K[3][7]*xhat_QC[7]
                                                 + K[3][8]*(xhat_QC[8]-QC_REF[8]) + K[3][9]*xhat_QC[9] + K[3][10]*xhat_QC[10] + K[3][11]*xhat_QC[11]);

//            u_QC_alt = u;
            txDataQC1[0] = (u_QC[0]+QC_U_OFFSET[0])*QC_U_FACTOR[0];
            txDataQC1[1] = (u_QC[1]+QC_U_OFFSET[1])*QC_U_FACTOR[1];
            txDataQC2[0] = (u_QC[2]+QC_U_OFFSET[2])*QC_U_FACTOR[2];
            txDataQC2[1] = (u_QC[3]+QC_U_OFFSET[3])*QC_U_FACTOR[3];

            printf("calculated qc data 2 %f data 3 %f, tx data %u, %u for sensor data %f and estimated states [%f; %f; %f; %f] at %d\n", u_QC[2], u_QC[3], txDataQC2[0], txDataQC2[1], y_QC, xhat_QC[0], xhat_QC[1], xhat_QC[2], xhat_QC[3], i);//stopped for testing
            /* doing the rest periodically */
//            txData2[0] = ((u1_P5 + C5_U1_offset)*C5_U1_factor);
//            txData2[1] = 0;
//
//            /* Initialise the message structure */
//            IfxCan_Message txMsg;
//            IfxCan_Can_initMessage(&txMsg);
//
//            txMsg.messageId = 0x517;
//            txMsg.bufferNumber = 1;

//            /*Transmit Data*/
//            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData2) == IfxCan_Status_notSentBusy)
//                printf("sent data\n");
            curIdx_qc = curIdx_qc + 1;
}


void CanBasicDemo_run_qc_alt(void)  /*     This is the code of QC     */
{
//    uint32 txData2[2];
    float a[4][4] = {{1,   0.01,  0,  0},
                     {0,    1,   0,   0},
                     {0,   0,    1,   0.01},
                     {0,    0,    0,   1}};

    float b[4][2] = {{0, 0}, {0.002, 0},  {0, 0}, {0, 0.001}};

    float c[4][4] = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};

    float d[4][2] = {{0, 0},{0, 0},{0, 0},{0, 0}};

    float K[2][4] = {{3.14451685869324,          5.61640885706677,     -2.24815378560498e-13,     -9.35040910781222e-13},
                                {-2.40306241803692e-13,     -4.72815380478954e-13,         0.315827253270447,          2.53304005481979}};

//    float L[4][1] = {{0.627216669816835}, {0.0776672166534822}, {0.0335031868276192}, {0.804439585315085}};
    if (h_list[task_per[0]]==8 || h_list[task_per[0]]==40){/*  qc altitude control code  0.008s */
        printf("Acquiring system matrices for task qc alt, periodicity 40\n");
        float K[2][4] =  {{3.14806101403323, 5.61958299359191,    -1.06574271596490e-13,   -3.51167300129546e-13},
         {-1.40612070043267e-13, -1.55665450866325e-13,   0.315907315209643,   2.53336608803131}};
    }
    if (h_list[0][task_per[0]]==10){/*  qc altitude control code  0.01s */
        printf("Acquiring system matrices for task qc alt, periodicity 10\n");
             float  a[4][4] = {{1,   0.01,  0,  0},
                              {0,    1,   0,   0},
                              {0,   0,    1,   0.01},
                              {0,    0,    0,   1}};

             float b[4][2] = {{0, 0}, {0.002, 0}, {0, 0}, {0, 0.001}};

//             float c[][] = {{1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1}};
//
//             float d[][] = {{0, 0},{0, 0},{0, 0},{0, 0}};

           float K[2][4] = {{3.14451685869324,          5.61640885706677,     -2.24815378560498e-13,     -9.35040910781222e-13},
                            {-2.40306241803692e-13,     -4.72815380478954e-13,         0.315827253270447,          2.53304005481979}};

//           float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

    }else  if (h_list[0][task_per[0]]==20){/*  qc altitude control code  0.02s */
        printf("Acquiring system matrices for task qc alt, periodicity 20\n");
             float a[4][4] = {{1,   0.02,  0,  0},
                         {0,    1,   0,   0},
                         {0,   0,    1,   0.02},
                         {0,    0,    0,   1}};

             float b[4][2] = {{0, 0}, {0.004, 0},  {0, 0}, {0, 0.002}};

//             float c[][] = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
//
//             float d[][] = {{0, 0},{0, 0},{0, 0},{0, 0}};

             float K[2][4] = {{3.12685594967393,          5.60056530879117,     -8.20209119000962e-15,     -1.04128354000384e-13},
                               {-2.27958236698399e-15,     -5.25758397334492e-14,         0.315427247946649,          2.53141053716782}};
;

//       float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

    }else if (h_list[0][task_per[0]]==30){/*  qc altitude control code  0.03s */
        printf("Acquiring system matrices for task qc alt, periodicity 30\n");
             float a[4][4] = {{1,   0.03,  0,  0},
                         {0,    1,   0,   0},
                         {0,   0,    1,   0.03},
                         {0,    0,    0,   1}};

             float b[4][2] = {{0, 0}, {0.006, 0},  {0, 0}, {0, 0.003}};

//             float c[][] = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
//
//             float d[][] = {{0, 0},{0, 0},{0, 0},{0, 0}};

             float K[2][4] = {{3.10929450940453,          5.58476697969132,      1.63721429561644e-14,     -3.56030803834745e-15},
                               {-9.08613371101948e-16,     -1.52517184180782e-15,         0.315027749563069,          2.52978210015362}};


//       float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

    }
    //

//       float check = xA - xhatA;

//          float new_xhat[4][1]={{0},{0},{0},{0}};
//            float xhatA
            xhat_QC_alt[0] = ((float)y_QC[0]/(float)QC_X_FACTOR[0])-(float)QC_X_OFFSET[0];//xhat_QC_alt[0];
//            float xhatB
            xhat_QC_alt[1] = ((float)y_QC[1]/(float)QC_X_FACTOR[1])-(float)QC_X_OFFSET[1];//xhat_QC_alt[1];
//            float xhatC
            xhat_QC_alt[2] = ((float)y_QC[2]/(float)QC_X_FACTOR[2])-(float)QC_X_OFFSET[2];//xhat_QC_alt[2];
//            float xhatD
            xhat_QC_alt[3] = ((float)y_QC[3]/(float)QC_X_FACTOR[3])-(float)QC_X_OFFSET[3];//xhat_QC_alt[3];

//          float y = ((float)y1_QC_alt/(float)QC_XA_factor)-(float)QC_XA_offset;
//          float xB = (xB_P5/(float)P5_XB_factor)-P5_XB_offset;
//          printf("qc sensor data = %u op =  %f at %d\n",y1_QC_alt, xhatA, i);
//          float u = u_QC_alt;
//          new_xhat[0][0]
//                      xhat_QC_alt[0] = a[0][0]*xhatA + a[0][1]*xhatB + a[0][2]*xhatC + a[0][3]*xhatD + u*b[0][0] ;//+ L[0][0]*(y-xhatA);
//          new_xhat[1][0]
//                      xhat_QC_alt[1] = a[1][0]*xhatA + a[1][1]*xhatB + a[1][2]*xhatC + a[1][3]*xhatD + u*b[1][0] ;//+ L[1][0]*(y-xhatA);
//          new_xhat[2][0]
//                      xhat_QC_alt[2] = a[2][0]*xhatA + a[2][1]*xhatB + a[2][2]*xhatC + a[2][3]*xhatD + u*b[2][0] ;//+ L[2][0]*(y-xhatA);
//          new_xhat[3][0]
//                      xhat_QC_alt[3] = a[3][0]*xhatA + a[3][1]*xhatB + a[3][2]*xhatC + a[3][3]*xhatD + u*b[3][0] ;//+ L[3][0]*(y-xhatA);

//          xhat_SC[0] = new_xhat[0][0];
//          xhat_SC[1] = new_xhat[1][0];
//          xhat_SC[2] = new_xhat[2][0];
//          xhat_SC[3] = new_xhat[3][0];

//            if (i > 100000 && i < 200000)
//                xhat_QC_alt[0] = xhat_QC_alt[0] + rand()% 2;

            u_QC_alt[0] = -(K[0][0]*(xhat_QC_alt[0]-QC_REF_alt[0]) + K[0][1]*xhat_QC_alt[1] + K[0][2]*xhat_QC_alt[2] + K[0][3]*xhat_QC_alt[3]);
            u_QC_alt[1] = -(K[1][0]*(xhat_QC_alt[0]-QC_REF_alt[0]) + K[1][1]*xhat_QC_alt[1] + K[1][2]*xhat_QC_alt[2] + K[1][3]*xhat_QC_alt[3]);
//            printf("multiplying K[%d][%d]=%f with xhat[%d]=%f minum %f in u[%d]= %f\n ", ii, jj, K[ii][jj], jj, xhat_QC[jj], QC_REF[jj], ii,  u_QC[ii]);
//            u_QC_alt = u;
            txDataQC_alt[0] = (u_QC_alt[0]+QC_U_OFFSET[0])*QC_U_FACTOR[0];
            txDataQC_alt[1] = (u_QC_alt[1]+QC_U_OFFSET[1])*QC_U_FACTOR[1];
            printf("calculated qc alt data %f tx data %u for sensor data %f and estimated states [%f; %f; %f; %f] at %d\n", u_QC_alt[0], txDataQC_alt[0], y_QC[5], xhat_QC_alt[0], xhat_QC_alt[1], xhat_QC_alt[2], xhat_QC_alt[3], i);//stopped for testing
            /* doing the rest periodically */
//            txData2[0] = ((u1_P5 + C5_U1_offset)*C5_U1_factor);
//            txData2[1] = 0;
//
//            /* Initialise the message structure */
//            IfxCan_Message txMsg;
//            IfxCan_Can_initMessage(&txMsg);
//
//            txMsg.messageId = 0x517;
//            txMsg.bufferNumber = 1;

//            /*Transmit Data*/
//            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData2) == IfxCan_Status_notSentBusy)
//                printf("sent data\n");
            curIdx_qc_alt = curIdx_qc_alt + 1;
}

/*----------- dummy tasks for spending compute resource -----------*/

void dummy_comp1(){
    const int MATRIX_SIZE = 60;
    double matrix_a [MATRIX_SIZE][MATRIX_SIZE];
    double matrix_b [MATRIX_SIZE][MATRIX_SIZE];
    double result_matrix [MATRIX_SIZE][MATRIX_SIZE];
    // Initialize matrices with random values
    int i, j, k = 0;
    while (i < MATRIX_SIZE) {
        while (j < MATRIX_SIZE) {
            matrix_a[i][j] = 1234500.0;//(double)rand() / RAND_MAX;
            matrix_b[i][j] = 123456.0;//(double)rand() / RAND_MAX;
            j++;
        }
        i++;
    }

    // Measure computation time
    clock_t start_time = clock();
    i,j,k = 0;
    l = 50;
    // Perform heavy computation
    // perform_multiplication(matrix_a, matrix_b, result_matrix);
    while (l > 0) {
        while (i < MATRIX_SIZE) {
            while (j < MATRIX_SIZE) {
                result_matrix[i][j] = 0.0;
                while (k < MATRIX_SIZE) {
                    result_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j];
                    k++;
                }
                j++;
            }
            i++;
        }
        l-- ;
    }
    // Calculate computation time
    clock_t end_time = clock();
    double computation_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;

    // Print computation time
//    printf("Computation time: %.6f seconds\n", computation_time);
}

